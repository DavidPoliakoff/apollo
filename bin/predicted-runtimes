#!/usr/bin/env python
import sys

import itertools

import numpy as np
import pandas as pd

from rlsl.learn import get_kfold_score, get_kfold_pem_score, get_pem_time
from rlsl.util import df_to_unique_csv
from rlsl.util.dtypes import LULESH_DTYPE, PATH_DTYPE
from rlsl.util.sciload import PandasFeatureLoader, PandasInstructionLoader
from rlsl.util.timer import Timer
from rlsl.metrics.performance import PerformanceErrorMetric, RuntimeScorer

from sklearn.feature_extraction import DictVectorizer
import sklearn.preprocessing
from sklearn.tree import DecisionTreeClassifier
from sklearn.linear_model import SGDClassifier
from sklearn.metrics import make_scorer
from sklearn.svm import SVC
from sklearn.ensemble import GradientBoostingClassifier, RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.cross_validation import train_test_split
from sklearn.utils import shuffle

CLASSIFIERS = [
    'DecisionTreeClassifier',
    'RandomForestClassifier',
    'KNeighborsClassifier',
    ]

clfs = []

NAMES = PATH_DTYPE['names']

deck = sys.argv[1]
instructions = sys.argv[2]

INPUT = {
        'deck': deck,
        'instructions': instructions
        }

data = PandasFeatureLoader('/Users/david/PhD/Research/Papers/SC 2015 Machine Learning/data/learning/with-path/%s.csv' % INPUT['deck'], NAMES)
instruction_data = PandasInstructionLoader('/Users/david/PhD/Research/Papers/SC 2015 Machine Learning/data/learning/%s-instructions.csv' % INPUT['instructions'])

print "Running %s with instruction %s..." % (deck, instructions)

all_data = pd.merge(data.get_data(), instruction_data.get_data().fillna(0), on='loop')

df = all_data

for c in CLASSIFIERS:
    clfs.append(globals()[c]())

#feature_names = [x for x in list(df) if x not in ['time', 'outer', 'inner', 'outer_best', 'inner_best', 'time_best', 'loop']]
feature_names = [x for x in list(df) if x not in ['time', 'outer', 'inner', 'outer_best', 'inner_best', 'time_best', 'loop', 'path']]
loop_feature_names = [x for x in list(df) if x not in ['time', 'outer', 'inner', 'outer_best', 'inner_best', 'time_best', 'path']]

df['inner_outer_best'] = df.apply(lambda row:
        str(row['inner_best'] + ' ' + row['outer_best']), axis=1)

y_cat = df[['inner_outer_best']].T.to_dict().values()

y_vec = DictVectorizer(sparse=False)
y_lab = sklearn.preprocessing.LabelEncoder()

y = y_lab.fit_transform(y_cat)

x_num = df[[x for x in feature_names if x not in ['loop type', 'set type']]].as_matrix()
x_num_loop = df[[x for x in loop_feature_names if x not in ['loop type', 'set type']]].as_matrix()

x_cat = df[[x for x in ['loop type', 'set type'] if x in feature_names]].T.to_dict().values()

vectorizer = DictVectorizer(sparse=False)
vec_x_cat = vectorizer.fit_transform(x_cat)

X = np.hstack((x_num, vec_x_cat))
X_loop = np.hstack((x_num_loop, vec_x_cat))

X, X_loop, y = shuffle(X,X_loop,y)
pem_scorer = PerformanceErrorMetric(df, [x for x in loop_feature_names if x not in ['loop type', 'set type']], y_lab)

print "Getting predicted times..."
pem = [get_pem_time(clf, X_loop, X, y, scoring=pem_scorer.get_predicted_times) for clf in clfs]
print "DONE"

print pem

scores = []
for time,label in zip(pem, CLASSIFIERS):
    for size in time:
        score_map = {'problem size': size,
                'classifier':label,
                'time':time[size]}

        scores.append(score_map)

scores_df = pd.DataFrame(scores)

for classifier in np.unique(scores_df['classifier']):
    scores_df[classifier] = scores_df[scores_df['classifier'] == classifier]['time']

df_to_unique_csv(scores_df, "%s-predicted-time" % INPUT['deck'])

#
# #importances = []
# #ilist = []
# #
# #for clf,label in zip(clfs,CLASSIFIERS):
# #    clf.fit(X, y)
# #    importances = clf.feature_importances_
# #    indices = np.argsort(importances)[::-1]
# #
# #    print("Feature ranking:")
# #    for f in range(len(importances)):
# #        imap = {'rank': f+1,
# #                'feature_name': feature_names[indices[f]],
# #                'importance':importances[indices[f]],
# #                'classifier':label}
# #
# #        print("%d. %s (%f)" % (f + 1, feature_names[indices[f]], importances[indices[f]]))
# #        ilist.append(imap)
# #
# #idf = pd.DataFrame(ilist)
# #idf.to_csv('%s-importances.csv' % APP)
